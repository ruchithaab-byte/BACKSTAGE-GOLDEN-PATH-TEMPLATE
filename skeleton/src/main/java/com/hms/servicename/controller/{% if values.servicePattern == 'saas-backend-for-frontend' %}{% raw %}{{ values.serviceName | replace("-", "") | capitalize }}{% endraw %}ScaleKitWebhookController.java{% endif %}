package com.hms.{{ values.serviceName | replace("-", "") }}.controller;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.hms.lib.common.security.PermitSyncService;
import com.hms.{{ values.serviceName | replace("-", "") }}.model.UserEntity;
import com.hms.{{ values.serviceName | replace("-", "") }}.repository.UserRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;

/**
 * Webhook endpoint for ScaleKit directory events.
 * 
 * This endpoint serves as a fail-safe: if an admin changes a user in ScaleKit
 * dashboard (bypassing HMS UI), this webhook catches it and updates the local shadow DB.
 * 
 * CRITICAL: Must verify webhook signature to prevent unauthorized updates.
 */
@RestController
@RequestMapping("/webhooks")
public class {{ values.serviceName | replace("-", "") | capitalize }}ScaleKitWebhookController {

    private static final Logger log = LoggerFactory.getLogger({{ values.serviceName | replace("-", "") | capitalize }}ScaleKitWebhookController.class);

    @Value("${scalekit.webhook.secret}")
    private String webhookSecret;

    private final UserRepository userRepository;
    private final PermitSyncService permitSyncService;
    private final ObjectMapper objectMapper;

    @Autowired
    public {{ values.serviceName | replace("-", "") | capitalize }}ScaleKitWebhookController(
            UserRepository userRepository,
            PermitSyncService permitSyncService,
            ObjectMapper objectMapper) {
        this.userRepository = userRepository;
        this.permitSyncService = permitSyncService;
        this.objectMapper = objectMapper;
    }

    @PostMapping("/scalekit")
    @Transactional
    public ResponseEntity<Void> handleScaleKitWebhook(
            @RequestBody String rawBody,
            @RequestHeader("X-Scalekit-Signature") String signature) {

        try {
            if (!verifySignature(rawBody, signature, webhookSecret)) {
                log.warn("Invalid webhook signature - rejecting request");
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }

            JsonNode event = objectMapper.readTree(rawBody);
            String eventType = event.get("type").asText();
            log.info("Received ScaleKit webhook event: {}", eventType);

            switch (eventType) {
                case "scalekit.dir.user.create":
                case "scalekit.dir.user.update":
                    handleUserCreateOrUpdate(event);
                    break;
                case "scalekit.dir.user.delete":
                    handleUserDelete(event);
                    break;
                case "scalekit.dir.organization.create":
                case "scalekit.dir.organization.update":
                    handleOrganizationCreateOrUpdate(event);
                    break;
                default:
                    log.debug("Unhandled webhook event type: {}", eventType);
            }

            return ResponseEntity.ok().build();

        } catch (Exception e) {
            log.error("Error processing ScaleKit webhook", e);
            return ResponseEntity.ok().build();
        }
    }

    private void handleUserCreateOrUpdate(JsonNode event) {
        JsonNode userData = event.get("data");
        String userId = userData.get("id").asText();
        String email = userData.has("email") ? userData.get("email").asText() : null;
        String firstName = userData.has("firstName") ? userData.get("firstName").asText() : null;
        String lastName = userData.has("lastName") ? userData.get("lastName").asText() : null;
        
        String organizationId = null;
        if (userData.has("organizationId")) {
            organizationId = userData.get("organizationId").asText();
        }

        userRepository.findById(userId).ifPresentOrElse(
                existingUser -> {
                    if (email != null) existingUser.setEmail(email);
                    if (firstName != null) existingUser.setFirstName(firstName);
                    if (lastName != null) existingUser.setLastName(lastName);
                    userRepository.save(existingUser);
                    log.info("Updated shadow user from webhook: userId={}", userId);
                },
                () -> {
                    UserEntity newUser = new UserEntity();
                    newUser.setId(userId);
                    newUser.setEmail(email != null ? email : "");
                    newUser.setFirstName(firstName);
                    newUser.setLastName(lastName);
                    newUser.setActive(true);
                    userRepository.save(newUser);
                    log.info("Created shadow user from webhook: userId={}", userId);
                }
        );

        if (email != null) {
            permitSyncService.syncUserAsync(userId, email, firstName, lastName, organizationId);
        }
    }

    private void handleUserDelete(JsonNode event) {
        JsonNode userData = event.get("data");
        String userId = userData.get("id").asText();
        userRepository.findById(userId).ifPresent(user -> {
            user.setActive(false);
            userRepository.save(user);
            log.info("De-provisioned user from webhook: userId={}", userId);
        });
    }

    private void handleOrganizationCreateOrUpdate(JsonNode event) {
        JsonNode orgData = event.get("data");
        String orgId = orgData.get("id").asText();
        String orgName = orgData.has("name") ? orgData.get("name").asText() : orgId;
        permitSyncService.syncOrganizationAsync(orgId, orgName);
    }

    private boolean verifySignature(String rawBody, String signature, String secret) {
        try {
            Mac mac = Mac.getInstance("HmacSHA256");
            SecretKeySpec secretKeySpec = new SecretKeySpec(secret.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
            mac.init(secretKeySpec);
            byte[] computedHash = mac.doFinal(rawBody.getBytes(StandardCharsets.UTF_8));
            String computedSignature = bytesToHex(computedHash);
            return constantTimeEquals(computedSignature, signature);
        } catch (Exception e) {
            log.error("Error verifying webhook signature", e);
            return false;
        }
    }

    private String bytesToHex(byte[] bytes) {
        StringBuilder result = new StringBuilder();
        for (byte b : bytes) {
            result.append(String.format("%02x", b));
        }
        return result.toString();
    }

    private boolean constantTimeEquals(String a, String b) {
        if (a.length() != b.length()) return false;
        int result = 0;
        for (int i = 0; i < a.length(); i++) {
            result |= a.charAt(i) ^ b.charAt(i);
        }
        return result == 0;
    }
}
