-- ============================================================================
-- CREATE SCHEMA: {{ values.schemaName }}
-- Generated by HIMS Platform Schema Scaffolding
-- ============================================================================
-- 
-- This migration creates a new schema with:
-- - Schema creation
-- - RLS enablement
-- - Basic tenant isolation setup
-- 
-- Assumes Core Kernel sets:
-- - app.current_tenant (via MultiTenantConnectionProvider)
-- - app.current_user (via MultiTenantConnectionProvider)
-- ============================================================================

-- Create schema
CREATE SCHEMA IF NOT EXISTS {{ values.schemaName }};

-- Set search path to this schema
SET search_path TO {{ values.schemaName }};

-- ============================================================================
-- EXAMPLE TABLE (Replace with actual table definitions)
-- ============================================================================
-- This is a template - replace with your actual table structure
-- 
-- Key Requirements:
-- 1. All tables MUST have tenant_id UUID column
-- 2. All tables MUST have audit columns (created_at, updated_at, created_by, updated_by)
-- 3. RLS policies MUST reference app.current_tenant
-- 4. No cross-schema foreign keys (use soft references via UUIDs)
-- ============================================================================

CREATE TABLE IF NOT EXISTS {{ values.schemaName }}.example_table (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Tenant isolation (REQUIRED)
    tenant_id UUID NOT NULL,
    
    -- Audit columns (REQUIRED)
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_by UUID,
    updated_by UUID,
    
    -- Business columns (replace with actual columns)
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Compliance fields (optional - see V002__add_compliance_fields.sql)
    {% if values.includeComplianceFields %}
    encryption_key_id VARCHAR(255),
    data_sovereignty_tag VARCHAR(100),
    consent_ref UUID,
    {% endif %}
    
    -- Indexes
    CONSTRAINT example_table_tenant_id_fk FOREIGN KEY (tenant_id) 
        REFERENCES core.tenants(id) ON DELETE CASCADE
);

-- Create indexes for tenant isolation
CREATE INDEX IF NOT EXISTS idx_example_table_tenant_id 
    ON {{ values.schemaName }}.example_table(tenant_id);
CREATE INDEX IF NOT EXISTS idx_example_table_created_at 
    ON {{ values.schemaName }}.example_table(created_at);

-- ============================================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================
-- These policies enforce tenant isolation using app.current_tenant
-- set by the Core Kernel's MultiTenantConnectionProvider
-- ============================================================================

-- Enable RLS on the table
ALTER TABLE {{ values.schemaName }}.example_table ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only see rows for their tenant
CREATE POLICY tenant_isolation_policy ON {{ values.schemaName }}.example_table
    FOR ALL
    USING (tenant_id::text = current_setting('app.current_tenant', true))
    WITH CHECK (tenant_id::text = current_setting('app.current_tenant', true));

-- Policy: System operations (for migrations, etc.) can bypass RLS
-- Note: This should be restricted in production
CREATE POLICY system_bypass_policy ON {{ values.schemaName }}.example_table
    FOR ALL
    TO postgres
    USING (true)
    WITH CHECK (true);

-- ============================================================================
-- TRIGGERS
-- ============================================================================

-- Trigger to update updated_at timestamp
CREATE OR REPLACE FUNCTION {{ values.schemaName }}.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    NEW.updated_by = current_setting('app.current_user', true)::UUID;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_example_table_updated_at
    BEFORE UPDATE ON {{ values.schemaName }}.example_table
    FOR EACH ROW
    EXECUTE FUNCTION {{ values.schemaName }}.update_updated_at_column();

-- Trigger to set created_by
CREATE OR REPLACE FUNCTION {{ values.schemaName }}.set_created_by_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.created_by = current_setting('app.current_user', true)::UUID;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_example_table_created_by
    BEFORE INSERT ON {{ values.schemaName }}.example_table
    FOR EACH ROW
    EXECUTE FUNCTION {{ values.schemaName }}.set_created_by_column();

-- ============================================================================
-- GRANTS
-- ============================================================================

-- Grant usage on schema
GRANT USAGE ON SCHEMA {{ values.schemaName }} TO application_role;

-- Grant privileges on table
GRANT SELECT, INSERT, UPDATE, DELETE ON {{ values.schemaName }}.example_table TO application_role;

-- ============================================================================
-- NOTES
-- ============================================================================
-- 1. Replace 'example_table' with your actual table name
-- 2. Replace business columns with your actual columns
-- 3. Add additional indexes as needed
-- 4. Compliance fields are optional (see includeComplianceFields flag)
-- 5. RLS policies assume app.current_tenant is set by Core Kernel
-- 6. No cross-schema foreign keys - use soft references (UUIDs)
-- ============================================================================

